import fs from "node:fs";
import path from "node:path";

/**
 * Build-time generator that converts simple JSON palette files in /public into TS constants.
 *
 * Supported formats:
 * - Record<codeOrName, hex>  (e.g. Hama_Midi.json, Nabbi.json, Ikea_Pyssla.json, Perler.json)
 *
 * Output:
 * - src/lib/generatedJsonPalettes.ts
 */

const ROOT = process.cwd();
const OUT_TS = path.join(ROOT, "src", "lib", "generatedJsonPalettes.ts");

const SOURCES = [
  { key: "Hama-Midi", label: "Hama Midi", file: "public/Hama_Midi.json", brand: "Hama", idPrefix: "Hama", seriesFromKey: true },
  { key: "Nabbi", label: "Nabbi", file: "public/Nabbi.json", brand: "Nabbi", idPrefix: "Nabbi", seriesFromKey: true },
  { key: "Ikea-Pyssla", label: "Ikea Pyssla", file: "public/Ikea_Pyssla.json", brand: "Ikea-Pyssla", idPrefix: "Ikea", seriesFromKey: false },
  // This Perler.json maps names -> hex (no numeric SKU). We keep it as an alternate "named" palette.
  { key: "Perler-Names", label: "Perler (Names)", file: "public/Perler.json", brand: "Perler", idPrefix: "PerlerName", seriesFromKey: false },
];

function rgbHexNormalize(hex) {
  const h = String(hex).trim();
  if (!/^#[0-9a-fA-F]{6}$/.test(h)) return "#000000";
  return h.toUpperCase();
}

function seriesFromCode(code) {
  const m = String(code).match(/^[^\d]+/);
  return m ? m[0] : "";
}

function toTs(out) {
  return out.join("\n") + "\n";
}

function main() {
  const out = [];
  out.push(`/* AUTO-GENERATED FILE. DO NOT EDIT MANUALLY.`);
  out.push(` *`);
  out.push(` * Source: public/*.json (Hama_Midi, Nabbi, Ikea_Pyssla, Perler)`);
  out.push(` * Generated by: scripts/generate-json-palettes.mjs`);
  out.push(` */`);
  out.push("");
  out.push(
    `export type JsonBeadColor = { id: string; name: string; hex: string; brand: string; code: string; productCode: string; series: string };`
  );
  out.push("");

  const registry = [];

  for (const s of SOURCES) {
    const abs = path.join(ROOT, s.file);
    if (!fs.existsSync(abs)) {
      console.warn(`Skipping missing palette file: ${s.file}`);
      continue;
    }
    const raw = fs.readFileSync(abs, "utf8");
    const map = JSON.parse(raw);
    const keys = Object.keys(map);

    const palette = keys
      .slice()
      .sort((a, b) => a.localeCompare(b, "en"))
      .map((codeOrName) => {
        const hex = rgbHexNormalize(map[codeOrName]);
        const code = codeOrName; // what we display in-grid (model code)
        return {
          id: `${s.idPrefix}:${codeOrName}`,
          name: codeOrName,
          hex,
          brand: s.brand,
          code,
          productCode: code,
          series: s.seriesFromKey ? seriesFromCode(codeOrName) : "",
        };
      });

    const constName = `PALETTE_${s.key.replace(/[^A-Za-z0-9]/g, "_").toUpperCase()}`;
    out.push(`export const ${constName}: JsonBeadColor[] = [`);
    for (const c of palette) {
      out.push(
        `  { id: ${JSON.stringify(c.id)}, name: ${JSON.stringify(
          c.name
        )}, hex: ${JSON.stringify(c.hex)}, brand: ${JSON.stringify(
          c.brand
        )}, code: ${JSON.stringify(c.code)}, productCode: ${JSON.stringify(
          c.productCode
        )}, series: ${JSON.stringify(c.series)} },`
      );
    }
    out.push(`];`);
    out.push("");

    registry.push({ key: s.key, label: s.label, constName });
  }

  out.push(`export const JSON_PALETTE_REGISTRY = {`);
  for (const r of registry) {
    out.push(`  ${JSON.stringify(r.key)}: ${r.constName},`);
  }
  out.push(`} as const;`);
  out.push("");

  out.push(`export const JSON_PALETTE_LABELS: Record<string, string> = {`);
  for (const r of registry) {
    out.push(`  ${JSON.stringify(r.key)}: ${JSON.stringify(r.label)},`);
  }
  out.push(`};`);
  out.push("");

  fs.mkdirSync(path.dirname(OUT_TS), { recursive: true });
  fs.writeFileSync(OUT_TS, toTs(out), "utf8");
  console.log(`Generated ${path.relative(ROOT, OUT_TS)} (${registry.length} palettes)`);
}

main();


